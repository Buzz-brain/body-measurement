1. General overview
Project goal

Build a “virtual body measurement system” that lets a user capture front/side photos, processes them with a measurement pipeline, and returns a set of anthropometric measurements with a per-measurement confidence score. The system supports user accounts, a dashboard for viewing history, and endpoints for image retrieval and measurement records.
High-level architecture

Single-page frontend app (React + Vite + TypeScript) communicates with a Python Flask backend over HTTPS (API endpoints).
Backend receives image uploads and user requests, runs measurement logic (MediaPipe/ML), stores measurement records and image references in a database, and returns JSON measurement objects to the frontend.
During development/demos, the local backend is exposed to the deployed frontend using ngrok (public tunneling). In production we planned Vercel for frontend and Render for backend (Render had free-tier memory limits so ngrok was used as a reliable dev/demo approach).
Communication flow

Frontend → HTTPS JSON requests → Backend endpoints (e.g. /api/login, /api/measurements).
Backend → Database (reads/writes measurement records, images).
Backend → (internal) ML/vision models for measurement calculation.
Frontend reads API responses and renders results (cards, overlays, optional 3D avatar).
Key repo files (representative)

rontend: frontend/src/pages/{Dashboard.tsx, Results.tsx, Auth.tsx, CaptureFlow.tsx}, frontend/src/contexts/AuthContext.tsx, frontend/src/services/measurementService.ts, frontend/src/components/measurement/*
Backend: app.py, config.py, routes/ (Flask routing), controllers/measurement_controller.py, models/ (DB model helpers)
Config/infra: frontend/.env, .env (backend), runtime files (for Render), requirements.txt, package.json
Technologies used

Frontend: React, TypeScript, Vite, Tailwind CSS, framer-motion, lucide-react (icons), React Router, Context API; MSW available for mocking in dev.
Backend: Python Flask, flask_jwt_extended for JWT auth, Flask-CORS for cross-origin, python-dotenv, MediaPipe and OpenCV (or simulated measurement pipeline), PyTorch (MiDaS / other depth models), torch/timm, TFLite delegate messages observed in logs.
Database / storage: MongoDB-like document store (ObjectId-style ids present in sample API responses); images stored as separate records (image id references).
Dev tools: ngrok (tunneling), Postman, Git, node/npm, pip + virtualenv, VS Code.
Deployment targets considered: Vercel (frontend), Render (backend). ngrok used for demonstrations / local exposure.

2. Frontend Development
Frameworks & libraries

React + TypeScript (Vite).
Styling: Tailwind CSS for atomic utility classes and theming.
UI: custom components (Card, Button) and small UI library components.
Animation: framer-motion for page/element transitions.
Icons: lucide-react.
State + routing: React Context for auth, react-router for pages.
Testing & tooling: Vitest config present; MSW used during local development to mock API endpoints.
Key pages / features

Auth (signup/login) — Auth.tsx + AuthContext.tsx for state and API login/register.
Dashboard — Dashboard.tsx (measurement list, quick actions, export CSV).
Capture flow — CaptureFlow.tsx (camera capture/upload flow).
Results — Results.tsx (measurement details, images, overlays, Avatar3D).
Settings / Help / Landing — auxiliary pages.
Local storage: token stored in localStorage as vbms_token. Local measurement cache service measurementService provides offline export, storage and CSV export.
UI/UX choices

Clean card-based dashboard layout with neutral background (bg-neutral-50) and primary accent colors for CTAs.
Typography: system fonts with Tailwind utility classes; headings emphasize clarity and scanning.
Animations: small framer-motion entrance/hover animations to improve perceived responsiveness and polish.
Flow: login → dashboard → capture → results. Dashboard provides quick export and average confidence metrics.

State management & routing

Auth handled via a Context (AuthContext.tsx) exposing login/register/logout and user state. Token is read from localStorage on app start and set with dispatch({ type: 'SET_USER', ... }).
Routing via react-router: Client-side navigation for pages and route params (/results/:id).
Responsiveness, interactivity, simulated data

Tailwind uses responsive classes; grid layouts adapt for mobile, tablet, desktop.
measurementService acts as a local fallback store for snapshots and CSV exports to support offline or demo flows.
MSW (Mock Service Worker) can intercept requests during development, useful for front-end work when backend is offline.
Animation & 3D visualization

Avatar3D component included to visualize body measurement result (placeholder or demo data). If implemented, it’s likely a Three.js/WebGL component or simplified 3D preview.
MeasurementOverlay and MeasurementCard present landmark overlays and measurement lines on top of images (SVG-based).
Frontend folder structure (representative)

frontend/
src/
pages/ (Auth, Dashboard, Results, CaptureFlow, Help)
components/
layout/ (Navigation)
measurement/ (MeasurementCard, MeasurementOverlay)
visualization/ (Avatar3D)
ui/ (Card, Button)
contexts/ (AuthContext + reducer)
services/ (measurementService.ts)
types/ (shared TS types)
main.tsx, index.css, App.tsx

User flow (textual screenshot/mocked walkthrough)

Landing → Login/Sign up
Dashboard shows recent measurement cards + quick actions
CaptureFlow: capture front/side images (camera or upload) → POST to /api/measurements (uploads)
Backend processes images → returns measurement object with each measurement’s value and confidence
Results page shows image, overlay, measurement cards, and optional Avatar3D
Dashboard lists historical records and supports CSV export
3. Backend Development
Stack & frameworks

Python Flask (app.py entry point) with modular controllers and routes.
flask_jwt_extended for authentication (JWT token creation and validation).
Flask-CORS configured in config.py to allow the frontend origins (dev/dev-server, Vercel, ngrok) and configured to support credentials and specific allowed headers.
python-dotenv used to load environment variables locally.
Routes and endpoints (main)

POST /api/signup — register new user (returns JWT token).
POST /api/login — login user (returns JWT token).
POST /api/measurements — upload images (front/side) and request processing. Returns created measurement record id.
GET /api/measurements — list measurement records for authenticated user.
GET /api/measurements/:id — fetch one record (including image ids, measurements object with confidence).
GET /api/images/:id — return image file / streaming.
(Other supportive endpoints: possibly /api/users, /api/images upload route glue – exact route names follow the examples above.

API documentation (example request/response)

GET /api/measurements
Headers: Authorization: Bearer <token>
Response: { records: [ { _id, created_at, user_id, front_image_id, side_image_id, height_cm, measurements: { chest_circumference: { cm, inches, confidence, landmarks: [..] }, ... } } ] }
GET /api/measurements/:id
Response: { record: {...} } (see Postman sample included previously)
POST /api/login
Body: { email, password }
Response: { token: <JWT> }
Measurement logic pipeline

measurement_controller.py encapsulates measurement logic:
Accepts images, runs pose estimation/landmark detection (MediaPipe or equivalent).
Optionally runs depth/height estimation via MiDaS or models (PyTorch) for full-length estimations.
Uses landmark pixel coordinates + image scale logic to compute circumferences and linear measurements.
Produces per-measurement confidence values based on landmark detection confidence or image clarity heuristics.
Saves computed values and landmark indices into a JSON-like measurements object attached to a record.

AI / CV integration

MediaPipe used for pose/landmark detection; PyTorch models (MiDaS/others) used for depth if required.
Logs show TFLite XNNPACK delegates and PyTorch cache usage (models loaded lazily and cached).
Because heavy ML models are memory-hungry, backend attempts lazy loading (load model on first request) and caching between requests.
Middleware & controllers

config.py sets JWT and CORS configuration used by Flask app.
Controllers (controllers/measurement_controller.py) are invoked by route handlers in routes/.
Middleware examples: auth middleware to decode JWT, CORS preflight responses, general error handlers that ensure JSON responses (important for the frontend which expects JSON).
Database connectivity & storage

Database connection code sits in models/ or a db module (MongoDB URI in .env). The backend stores records and keeps image references (front_image_id, side_image_id).
Image storage: images stored as separate documents or file storage with an id; endpoints provide images by id.
Backend folder structure (representative)

app.py (Flask app bootstrap)
config.py (CORS, JWT constants)
routes/ (route definitions and blueprints)
measurement_controller.py (processing)
models/ (DB access wrappers)
requirements.txt
Example measurement computation flow (frontend → backend)

Frontend POSTs form-data: frontImage, sideImage, gender, height.
Backend receives files → saves temp image(s) → measurement controller:
Run pose detection → extract landmark coordinates and per-landmark confidences.
Compute scale (estimated height or provided height) to convert pixels to cm.
Compute pairwise distances for circumferences / lengths; apply geometric approximations.
Assign a confidence score using heuristic combining landmark confidences, detection completeness, and image clarity.
Backend persists record in DB and returns record with measurement values and confidences.
4. Database Design
Technology & hosting

Document-oriented DB (MongoDB-like) — visible from ObjectId-like strings in sample responses.
Collections: users, measurements (records), images (binary or metadata), optionally sessions/logs.
Primary collections and fields (textual ER outline)

users

_id (ObjectId)
email (string)
password_hash (string) — store hashed password (bcrypt/argon2 recommended)
created_at
profile fields (name, etc.)
images

_id (ObjectId)
owner_id (user id)
created_at
filename / content-type
storage reference (binary blob, S3 key, GridFS id) — previously GridFS was attempted then removed from requirements due to deployment issues.

measurements (records)

_id (ObjectId)
user_id
front_image_id, side_image_id
created_at
processed_at
gender
height_cm (numeric)
measurements (object/dict) — nested object where each key is e.g. chest_circumference with:
cm (float), inches (float), confidence (float), landmarks (array of landmark indices)
status (string: queued, processing, completed)
metadata (model version, device info)
Relationships

users 1 — N measurements
measurements references images by id
Data operations

Create: POST /api/measurements saves image entries then measurement record once processed.
Read: GET /api/measurements lists recent records; GET /api/measurements/:id returns a record and image refs.
Update: status updates during processing; measurements filled in when processing completes.
Delete: deletes remove measurement document and image documents.
Validation & security

Backend validates request schema and required fields (file presence, types).
Server-side validation of numeric fields and nested measurement structure before DB insert.
Indexes: index on user_id for fast query of user records.

5. Integration flow (frontend ↔ backend)
Communication pattern

Frontend uses fetch (native) to call backend endpoints. Axios could be used, but current code uses fetch.
API_BASE is set by VITE_API_BASE env var (frontend/.env). For dev/demo, this was set to ngrok public URL.
All API calls attach JWT in Authorization header: Authorization: Bearer <token>.
Mock / simulation

MSW (Mock Service Worker) available for front-end dev so UI can be built without backend.
measurementService (local client-side) stores demo records for offline UI features or before backend is available.
Authentication & authorization

Registration/login endpoints return JWT tokens signed by backend secret (flask_jwt_extended).
Tokens stored in localStorage (vbms_token) and loaded into AuthContext on app start. (Note: storing tokens in localStorage is simple but has security tradeoffs—see security suggestions below).
Auth middleware on the backend verifies tokens for protected endpoints.
Data flow example (image capture → displayed result)

User captures front/side images in CaptureFlow → frontend POSTs to /api/measurements (multipart/form-data).
Backend receives images, runs detection/measurement pipeline, composes measurements object with confidences, persists, and returns record id or record JSON.
Frontend navigates to /results/:id and fetches GET /api/measurements/:id to render full record including image URLs.
Frontend displays images (GET /api/images/:id), measurement overlay, and measurement cards.
ngrok specifics (development)

ngrok used to expose local backend to the deployed frontend for demos.
ngrok’s browser warning page blocked first-time requests; solved by:
Adding ngrok-skip-browser-warning: 'true' header to fetch requests.
Adding that header to allowed CORS headers in backend config.py.
CORS configured explicitly in config.py to list allowed origins and allowed headers.
6. Testing & debugging
Testing approach

Manual testing: Postman used to validate endpoints and inspect JSON responses (sample Postman response was included).
Local end-to-end manual tests: login → capture → backend processing → results.
Frontend unit test scaffolding: vitest.config.ts present; small unit tests can be added.
Debugging tools & findings

Flask logs used to inspect incoming requests and runtime warnings.
Model logs show TFLite XNNPACK delegate warnings and PyTorch cache messages (normal for model usage).
ngrok web UI http://127.0.0.1:4040 used to monitor requests and CORS preflights during development.
MSW (Mock Service Worker) could sometimes intercept requests, causing Failed to fetch when MSW passthrough behavior changed.
Example test cases (manual)

Auth: signup with new email -> receive JWT -> token decodes to expected claims.
Measurements: POST images -> backend returns record with measurements object -> GET record returns same structure.
Images: GET /api/images/:id returns image binary or redirect; used successfully in Postman.

Known limitations & bugs encountered

Free hosting (Render free tier) lacked memory to load heavy ML models; fallback: local running + ngrok for demos.
ngrok browser warning required header to avoid HTML warnings in front-end.
Some SVG overlays produced NaN when landmark data missing — fixed with defensive checks in rendering components (recommend adding Number.isFinite checks).
Storing JWT in localStorage is functional but exposes the app to potential XSS token theft; recommended improvements suggested below.
7. Deployment & simulation
Deployment state

Frontend: configured for Vercel deployment (Vite build). vercel.json present.
Backend: attempted to deploy to Render (gunicorn, requirements.txt). Runtime issues due to Python versions and memory constraints were encountered; added .python-version and runtime.txt to help.
For demos, the backend is run locally inside a venv and exposed via ngrok (public HTTPS).
Environment configuration

Frontend reads VITE_API_BASE from .env.
Backend reads environment variables from .env and uses python-dotenv in dev.
config.py centralizes JWT and CORS config.
How offline & simulated behavior works

measurementService (client-side) allows storing and exporting measurements locally, enabling UI validation without server.
MSW allows frontend to simulate endpoints during development.
Deployment commands (examples)

Frontend (dev): npm run dev (Vite)
Frontend (build): npm run build, deployed to Vercel
Backend (dev): venv activate; python app.py
ngrok tunnel: ngrok http 5001 (then set VITE_API_BASE to ngrok URL in frontend env)
8. Security & best practices
Implemented security:

JWT authentication for protected endpoints (flask_jwt_extended).
Passwords should be hashed on the backend (bcrypt/argon2 recommended) — confirm implementation in your user model.
CORS is explicitly configured to allow only known origins and specific headers.
Environment variables for secrets configured via .env and not committed.
Areas to improve / recommendations:

Use refresh tokens and HttpOnly secure cookies to reduce XSS token exposure (avoid localStorage for long-term tokens).
Enforce server-side input validation for files (size, content-type), rate limit upload endpoints, and sanitize file names.
Enable HTTPS in production and use CSP headers; use signed URLs / temporary tokens for image retrieval if images are private.
Move heavy ML workloads to a dedicated service (GPU or more memory), or use an inference API to avoid memory issues on hosting platforms.
Add automated tests (unit and integration) and CI to run linting and tests.
Coding best practices followed

Separation of concerns: controllers handle logic, routes handle endpoint wiring, config centralizes constants.
Use of TypeScript on the frontend to provide type safety across components and services.
Reusable UI components and context-based state management for auth.
Performance improvements & optimizations

Lazy-loading ML models in the backend to avoid startup memory spikes.
Cache model artifacts and weights in local FS to speed subsequent runs.
Frontend: small image previews, optimized images and conditional rendering for overlays.
9. Tools & development environment
Tools used

Code editor: VS Code (implied)
Version control: Git (GitHub repo)
Package managers: npm (frontend), pip + venv (backend)
HTTP & testing: Postman, ngrok, MSW
Python packages: Flask, flask_jwt_extended, Flask-CORS, python-dotenv, opencv-python, mediapipe, torch/timm (MiDaS)
Node packages: React, Vite, Tailwind, framer-motion, lucide-react, vitest (tests)
Additional: ngrok (tunnel), gunicorn (for production).
Version control & branching

Project maintained on a single repository with main branch. Standard branching model recommended: feature branches, pull requests, code reviews.
Development notes

Use pip install -r requirements.txt in a venv and npm install for frontend.
Keep .env and secrets out of Git. Use Render / Vercel environment variable settings in production.
10. Summary output (for examiners / supervisor)
Concise summary

I built a full-stack virtual body measurement prototype. The frontend is a modern SPA (React + TypeScript + Tailwind) with pages for authentication, capture, dashboard and detailed measurement results (including overlays and optional 3D visualization). The backend is a Python Flask API that accepts images, runs a measurement pipeline using pose detection and optional depth models (MediaPipe, PyTorch models), computes measurements and confidence scores, and stores structured measurement records in a document store. Authentication is JWT-based. For development demos the local backend is exposed via ngrok; frontend fetches include an ngrok-skip-browser-warning header to avoid ngrok browser warnings and CORS preflight issues. Key engineering trade-offs: ML models are memory-intensive (so local/paid hosting recommended), and token storage uses localStorage for simplicity (with recommended improvements noted). Code is modular with separated controllers, config, and frontend contexts for testability and maintainability.
Why this demonstrates technical depth

Full-stack system design and integration of ML/CV components (pose estimation + depth/scale) with web APIs shows practical knowledge of model inference, data handling and UX design.
Real-world deployment concerns (CORS, tokens, host memory limits) were handled pragmatically: CORS configured explicitly, ngrok used for reliable demos, and backend configs adapted for target environments.
The implementation includes per-measurement confidence reporting — important for real applications that rely on measurement quality.
Suggested appendices / attachments for your chapters

Sample API request/response pairs (Postman export).
Representative frontend screenshots (dashboard, capture, results overlay).
Key code listings: measurement_controller.py, Results.tsx, AuthContext.tsx, config.py.
A short README addition documenting dev startup: python -m venv venv; venv\\Scripts\\Activate.ps1; pip install -r requirements.txt; python app.py and npm install; npm run dev with ngrok command ngrok http 5001.
Practical next steps and checklist for the report
Add 2–3 annotated screenshots: Dashboard, CaptureFlow, Results overlay.
Include the Postman JSON for sample measurement record (you already have it).
Insert the API endpoint table (method, path, required headers, sample payload & response).
Copy key snippets (≤ 30 lines) for measurement algorithm pseudocode from measurement_controller.py.
Include a “Known limitations & future work” section: deployment scaling, secure token storage, automated tests, model performance validation.

